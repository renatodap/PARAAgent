"""API router for conversational AI agent."""

from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Optional, Dict, Any
from datetime import datetime
from pydantic import BaseModel
from auth import get_current_user_id
from database import supabase
from agents.conversational_agent import ConversationalAgent

router = APIRouter()


class ChatMessage(BaseModel):
    """Single chat message."""
    role: str
    content: str


class ChatRequest(BaseModel):
    """Chat request from user."""
    message: str
    conversation_id: Optional[str] = None


class ChatResponse(BaseModel):
    """Agent's response."""
    conversation_id: str
    message: str
    tool_calls: Optional[List[Dict[str, Any]]] = None
    pending_confirmations: Optional[List[Dict[str, Any]]] = None
    metadata: Optional[Dict[str, Any]] = None


class ConversationSummary(BaseModel):
    """Summary of a conversation."""
    id: str
    title: str
    created_at: str
    updated_at: str
    message_count: int
    is_archived: bool


class ConfirmationRequest(BaseModel):
    """User's response to a pending confirmation."""
    modifications: Optional[Dict[str, Any]] = None  # For editing email drafts, etc.


@router.post("/chat", response_model=ChatResponse)
async def chat_with_agent(
    request: ChatRequest,
    user_id: str = Depends(get_current_user_id)
):
    """
    Chat with the AI agent.
    Automatically loads conversation history if conversation_id provided.
    Creates new conversation if not.
    """

    # Initialize agent
    agent = ConversationalAgent()

    # Load conversation history if continuing existing conversation
    conversation_history = []
    conversation_id = request.conversation_id

    if conversation_id:
        # Load existing conversation
        messages_result = supabase.table("conversation_messages")\
            .select("*")\
            .eq("conversation_id", conversation_id)\
            .order("created_at")\
            .execute()

        if not messages_result.data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Conversation not found"
            )

        # Convert to Claude format
        conversation_history = [
            {
                "role": msg["role"],
                "content": msg["content"]
            }
            for msg in messages_result.data
        ]
    else:
        # Create new conversation
        conversation_result = supabase.table("conversations")\
            .insert({
                "user_id": user_id,
                "title": None  # Will be auto-generated by trigger
            })\
            .execute()

        conversation_id = conversation_result.data[0]["id"]

    # Save user message to database
    supabase.table("conversation_messages")\
        .insert({
            "conversation_id": conversation_id,
            "role": "user",
            "content": request.message
        })\
        .execute()

    # Get agent response
    response = await agent.chat(
        user_id=user_id,
        message=request.message,
        conversation_history=conversation_history
    )

    # Save assistant message to database
    supabase.table("conversation_messages")\
        .insert({
            "conversation_id": conversation_id,
            "role": "assistant",
            "content": response["message"],
            "tool_calls": response.get("tool_calls"),
            "metadata": response.get("metadata")
        })\
        .execute()

    # Save any pending confirmations
    pending_confirmations = []
    if response.get("pending_confirmations"):
        for confirmation in response["pending_confirmations"]:
            confirmation_result = supabase.table("agent_confirmations")\
                .insert({
                    "conversation_id": conversation_id,
                    "user_id": user_id,
                    "action_type": confirmation["action_type"],
                    "action_data": confirmation["action_data"],
                    "status": "pending"
                })\
                .execute()

            pending_confirmations.append(confirmation_result.data[0])

    return ChatResponse(
        conversation_id=conversation_id,
        message=response["message"],
        tool_calls=response.get("tool_calls"),
        pending_confirmations=pending_confirmations,
        metadata=response.get("metadata")
    )


@router.get("/conversations", response_model=List[ConversationSummary])
async def get_conversations(
    user_id: str = Depends(get_current_user_id),
    include_archived: bool = False
):
    """Get all conversations for the current user."""

    query = supabase.table("conversations")\
        .select("id, title, created_at, updated_at, is_archived")\
        .eq("user_id", user_id)\
        .order("updated_at", desc=True)

    if not include_archived:
        query = query.eq("is_archived", False)

    result = query.execute()

    # Get message count for each conversation
    conversations = []
    for conv in result.data:
        message_count_result = supabase.table("conversation_messages")\
            .select("id", count="exact")\
            .eq("conversation_id", conv["id"])\
            .execute()

        conversations.append(
            ConversationSummary(
                id=conv["id"],
                title=conv["title"] or "New conversation",
                created_at=conv["created_at"],
                updated_at=conv["updated_at"],
                message_count=message_count_result.count or 0,
                is_archived=conv["is_archived"]
            )
        )

    return conversations


@router.get("/conversations/{conversation_id}", response_model=List[ChatMessage])
async def get_conversation_history(
    conversation_id: str,
    user_id: str = Depends(get_current_user_id)
):
    """Get full message history for a conversation."""

    # Verify ownership
    conversation = supabase.table("conversations")\
        .select("id")\
        .eq("id", conversation_id)\
        .eq("user_id", user_id)\
        .execute()

    if not conversation.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Conversation not found"
        )

    # Get messages
    messages_result = supabase.table("conversation_messages")\
        .select("role, content")\
        .eq("conversation_id", conversation_id)\
        .order("created_at")\
        .execute()

    return [
        ChatMessage(role=msg["role"], content=msg["content"])
        for msg in messages_result.data
    ]


@router.delete("/conversations/{conversation_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_conversation(
    conversation_id: str,
    user_id: str = Depends(get_current_user_id)
):
    """Delete a conversation (hard delete)."""

    # Verify ownership
    conversation = supabase.table("conversations")\
        .select("id")\
        .eq("id", conversation_id)\
        .eq("user_id", user_id)\
        .execute()

    if not conversation.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Conversation not found"
        )

    # Delete (cascade will handle messages and confirmations)
    supabase.table("conversations")\
        .delete()\
        .eq("id", conversation_id)\
        .execute()


@router.patch("/conversations/{conversation_id}/archive", status_code=status.HTTP_200_OK)
async def archive_conversation(
    conversation_id: str,
    user_id: str = Depends(get_current_user_id)
):
    """Archive a conversation (soft delete)."""

    # Verify ownership
    conversation = supabase.table("conversations")\
        .select("id")\
        .eq("id", conversation_id)\
        .eq("user_id", user_id)\
        .execute()

    if not conversation.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Conversation not found"
        )

    # Archive
    supabase.table("conversations")\
        .update({"is_archived": True})\
        .eq("id", conversation_id)\
        .execute()

    return {"status": "archived"}


@router.get("/confirmations", response_model=List[Dict[str, Any]])
async def get_pending_confirmations(
    user_id: str = Depends(get_current_user_id)
):
    """Get all pending confirmations for the user."""

    result = supabase.table("agent_confirmations")\
        .select("*")\
        .eq("user_id", user_id)\
        .eq("status", "pending")\
        .order("created_at", desc=True)\
        .execute()

    return result.data


@router.post("/confirmations/{confirmation_id}/approve", status_code=status.HTTP_200_OK)
async def approve_confirmation(
    confirmation_id: str,
    request: ConfirmationRequest,
    user_id: str = Depends(get_current_user_id)
):
    """Approve a pending confirmation and execute the action."""

    # Get confirmation
    confirmation_result = supabase.table("agent_confirmations")\
        .select("*")\
        .eq("id", confirmation_id)\
        .eq("user_id", user_id)\
        .eq("status", "pending")\
        .execute()

    if not confirmation_result.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Confirmation not found or already processed"
        )

    confirmation = confirmation_result.data[0]

    # Check if expired
    if datetime.fromisoformat(confirmation["expires_at"].replace('Z', '+00:00')) < datetime.now():
        supabase.table("agent_confirmations")\
            .update({"status": "expired"})\
            .eq("id", confirmation_id)\
            .execute()

        raise HTTPException(
            status_code=status.HTTP_410_GONE,
            detail="Confirmation has expired"
        )

    # Execute action based on type
    action_type = confirmation["action_type"]
    action_data = confirmation["action_data"]

    # Apply user modifications if provided
    if request.modifications:
        action_data.update(request.modifications)

    try:
        if action_type == "send_email":
            # Send email via Gmail MCP
            from mcp.gmail_mcp import GmailMCP
            from database import get_user_mcp_credentials

            credentials = get_user_mcp_credentials(user_id, "google")
            gmail = GmailMCP(credentials)

            result = gmail.send_email(
                to=action_data["to"],
                subject=action_data["subject"],
                body=action_data["body"],
                cc=action_data.get("cc"),
                bcc=action_data.get("bcc")
            )

            execution_result = {"email_id": result["id"], "status": "sent"}

        elif action_type == "create_task":
            # Create task in PARA system
            from database import db

            task_data = action_data.copy()
            task_data["user_id"] = user_id

            created_task = db.insert_record("tasks", task_data)
            execution_result = {"task_id": created_task["id"], "status": "created"}

        elif action_type == "delete_task":
            # Delete task
            from database import db

            success = db.delete_record("tasks", action_data["task_id"])
            execution_result = {"status": "deleted" if success else "failed"}

        else:
            execution_result = {"status": "unknown_action_type"}

        # Update confirmation status
        supabase.table("agent_confirmations")\
            .update({
                "status": "approved",
                "resolved_at": datetime.utcnow().isoformat(),
                "action_data": action_data  # Save modified data
            })\
            .eq("id", confirmation_id)\
            .execute()

        return {
            "status": "approved",
            "action_type": action_type,
            "execution_result": execution_result
        }

    except Exception as e:
        # Mark as failed but don't change status (user can retry)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to execute action: {str(e)}"
        )


@router.post("/confirmations/{confirmation_id}/reject", status_code=status.HTTP_200_OK)
async def reject_confirmation(
    confirmation_id: str,
    user_id: str = Depends(get_current_user_id)
):
    """Reject a pending confirmation."""

    # Get confirmation
    confirmation_result = supabase.table("agent_confirmations")\
        .select("id")\
        .eq("id", confirmation_id)\
        .eq("user_id", user_id)\
        .eq("status", "pending")\
        .execute()

    if not confirmation_result.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Confirmation not found or already processed"
        )

    # Update status
    supabase.table("agent_confirmations")\
        .update({
            "status": "rejected",
            "resolved_at": datetime.utcnow().isoformat()
        })\
        .eq("id", confirmation_id)\
        .execute()

    return {"status": "rejected"}
